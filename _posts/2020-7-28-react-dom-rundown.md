---
author: jordan-buysse
date: 2020-7-28
layout: post
slug: react-dom-rundown
title: "React DOM Rundown!"
categories:
- Research and Development
- Learning Notes
tags: 
- Javascript
- Computer Science
- React
- Trees
---

## The Problem: Re-rendering the DOM

One of the first mysteries you'll encounter when starting out with Javascript in the browser is the DOM. It's actually not so complicated: the whole HTML document gets parsed by the browser as a tree structure, based on the HTML tags and relationships between parent and child nodes. The DOM tree is created by a rendering engine like Webkit by reading the HTML document, parsing and applying CSS to the html in order to create the final tree.
This allows sites to respond to user events, (ie removing and item from a list) based on local changes to the browser. The problem though, is that manipultation can be a pain, hence the paradigm shift introduced by jQuery. jQuery made it easy to manipulate the DOM. But there was still a problem. It’s not so much that the manipulation itself is hard to understand, or that the DOM itself is badly structured, but the constant re-building of the DOM tree in the browser is a memory intensive process. Enter React (along with other modern frameworks) and the virtual DOM:

![The flow control for updating the virtual DOM](../static/img/react-dom-diagram.png)

As you can see, there are a lot of moving parts to re-render to the browser. Virtualizing the DOM allows modern frameworks like React to pick and choose what to update.

### The Virtual DOM

The virtual DOM is really just a control+c of the real DOM. Remember how I mentioned that the DOM tree itself isn’t the inefficient part, but rather the process of rebuilding it in the browser with Webkit is slow? Well, the virtual DOM allows us to keep the good parts of the DOM and enables us to batch changes and unlocks more performant stuff like batching changes.
React started it, but it’s the same idea for a lot of the contemporary web frameworks.

## React-specific implementation

You can actually see how all this works in its implementation via React. In your index.js file (generated by create-react-app unless you’re typing in your own boilerplate), you import ReactDOM from react, and call render on that object. The App component gets called and has its own render function, where the included JSX tells React’s template compiler how to build an in-memory DOM tree.
Whenever things change (usually a change in state), React still builds an entirely new DOM tree. The magic happens with React’s special diffing algorithm, which finds the minimum number of operations necessary in order to update the actual in-browser DOM. Rather than making those changes right away though, React will batch together the necessary changes and wait for the next lifecycle to implement them.

## Diffing the DOM

React’s process for understanding changes made to the DOM is also known as “reconciliation.” In theory, finding the minimum number of modifications required requires O(n^3) complexity. However, React can improve that by making a few assumptions. The first is to check the types of all elements by looking at the actual html tags used in JSX. If the type changes, React will simply replace the real DOM’s corresponding parent nodes with the new types from the virtual DOM.[^1] The second relates to something everyone finds out quite early in their experience with React:

    “Warning: Each child in an array or iterator should have a unique ‘key’ prop.%s%s See https://fb.me/react-warning-keys for more information.%s”

Sounds familiar, right? The ‘key’ prop allows React to amend child nodes at the speed of a hash table rather than iterating through an array of elements.[^2] This means that React’s reconciler (go checkout ReactChildReconciler.js!) only has to iterate through the new children of the new virtual DOM, checking for corresponding keys in the hash. It can then decide whether to update the child or simply mount/unmount it according to the lifecycle.

## Endnotes
[^1]: And here’s a nice little use case for breadth-first search in the wild! Since it’s more efficient to look for entire *subtrees* that need updating, React will work down the tree layer by layer so it doesn’t have to check all those child nodes for a new tag.
[^2]: I’m not sure that it applies directly, but this is the difference between 0(1) lookups and O(n) lookups in Hash Tables 101.
